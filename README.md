# ArithsGen â€“ tool for arithmetic circuits generation
## Description
ArithsGen presents an open source tool that enables generation of various arithmetic circuits along with the possibility to export them to various representations which all serve their specific purpose. C language for easy simulation, Verilog for logic synthesis, BLIF for formal verification possibilities and CGP to enable further global optimization.

### Usage
```bash
python3 generate_test.py
cd test_circuits
ls
```

### Example of generation
```py
    #Example generation of Verilog representation of 8-bit unsigned dadda multiplier that uses cla to provide the final product
	a = Bus(N=8, prefix="a_bus")
	b = Bus(N=8, prefix="b_bus")

	u_dadda = UnsignedDaddaMultiplier(a=a, b=b, prefix="h_u_dadda_cla8", unsigned_adder_class_name=UnsignedCarryLookaheadAdder)
	u_dadda.get_v_code_hier(open("h_u_dadda_cla8.v", "w"))
```

### Simple arithmetic circuits
See ()[rca.py]

### Complex circuits

```py
from ariths_gen.core.arithmetic_circuits.arithmetic_circuit import ArithmeticCircuit
from ariths_gen.core.arithmetic_circuits import GeneralCircuit
from ariths_gen.wire_components import Bus, Wire
from ariths_gen.multi_bit_circuits.adders import UnsignedRippleCarryAdder
from ariths_gen.multi_bit_circuits.multipliers import UnsignedArrayMultiplier, UnsignedDaddaMultiplier
import os

class MAC(GeneralCircuit):
    def __init__(self, a: Bus, b: Bus, r: Bus, prefix: str = "", name: str = "mac", **kwargs):
        super().__init__(prefix=prefix, name=name, out_N=2*a.N+1, inputs=[a, b, r], **kwargs)
        assert a.N == b.N
        assert r.N == 2 * a.N

        self.mul = self.add_component(UnsignedArrayMultiplier(a=a, b=b, prefix=self.prefix, name=f"u_arrmul{a.N}", inner_component=True))
        self.add = self.add_component(UnsignedRippleCarryAdder(a=r, b=self.mul.out, prefix=self.prefix, name=f"u_rca{r.N}", inner_component=True))
        self.out.connect_bus(connecting_bus=self.add.out)

# usage
if __name__ == "__main__":
    os.makedirs("test_circuits/mac", exist_ok=True)
    mymac = MAC(Bus("a", 8), Bus("b", 8), Bus("acc", 16))
    mymac.get_v_code_hier(open("test_circuits/mac/mac_hier.v", "w"))
    mymac.get_c_code_hier(open("test_circuits/mac/mac_hier.c", "w"))
    mymac.get_c_code_flat(open("test_circuits/mac/mac_flat.c", "w"))
```

## Documentation
https://ehw-fit.github.io/ariths-gen/


## Supporting various PDK kits
When one uses a specific process design kit (PDK), it is not effective to implement half- and full-adders using two-inputs logic gates. These circuits are directly implemented as CMOS modules and are more effective than heuristic optimization by synthesis tool. If you want to use for example FreePDK45 library, you can call a following function before verilog code generating.

```py
from ariths_gen import set_pdk45_library
set_pdk45_library()
```

You can add a support of arbitrary PDK (see an [example](ariths_gen/pdk.py) ).

## Formal verification
The `yosys_equiv_check.sh` script enables to formally check the equivalence of generated Verilog and BLIF representations of the same circuit.
It uses the Yosys Open SYnthesis Suite tool by Clifford Wolf. For further information, please visit: http://www.clifford.at/yosys/documentation.html.

## Execute permission
```bash
chmod +x yosys_equiv_check.sh
```

### Usage
```bash
./yosys_equiv_check.sh -v "verilog_file" -b "blif_file" [-H]
```

For more detailed description of script's usage, use help.
```bash
./yosys_equiv_check.sh -h|--help
```

## CGP testing
The `chr2c.py` script converts the input CGP chromosome generated by ArithsGen to the corresponding C code and prints it to standard output.

### Usage
```bash
python3 chr2c.py input.chr > output.c
```
