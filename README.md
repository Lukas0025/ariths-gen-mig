# ArithsGenMig â€“ tool for arithmetic circuits generation on MIG backend
[![made-with-python](https://img.shields.io/badge/Made%20with-Python-1f425f.svg)](https://www.python.org/)
[![Documentation](https://img.shields.io/badge/api-reference-blue.svg)](https://ehw-fit.github.io/ariths-gen)


## Description
ArithsGen presents an open source tool that enables generation of various arithmetic circuits along with the possibility to export them to various formats which all serve their specific purpose. C language for easy simulation, Verilog for logic synthesis, BLIF for formal verification possibilities and CGP to enable further global optimization.

In contrast to standard HDL languages Python supports
* Multiple output formats (BLIF, Verilog, C, Integer netlist)
* Advanced language construction (better configuration, inheritance, etc.)
* Support of various PDKs (for using library cells as half-adders and full-adders)

## Reference
When you use this tool in your work/research, please cite the following article: KLHUFEK Jan and MRAZEK Vojtech. ArithsGen: Arithmetics Circuit Generator for HW Accelerators. In: 2022 25th International Symposium on Design and Diagnostics of Electronic Circuits and Systems (DDECS '22). Prague, 2022, p. 4.

```bibtex
@INPROCEEDINGS{klhufek:DDECS22,
   author = "Jan Klhufek and Vojtech Mrazek",
   title = "ArithsGen: Arithmetics Circuit Generator for HW Accelerators",
   pages = 4,
   booktitle = "2022 25th International Symposium on Design and Diagnostics of Electronic Circuits and Systems (DDECS '22)",
   year = 2022,
   location = "Prague, CZ"
}
```

### Usage
```bash
python3 generate_test.py
cd test_circuits
ls
```

### Example of generation
```py
#Example generation of Verilog representation of 8-bit unsigned dadda multiplier that uses cla to provide the final product
a = Bus(N=8, prefix="a_bus")
b = Bus(N=8, prefix="b_bus")

u_dadda = UnsignedDaddaMultiplier(a=a, b=b, prefix="h_u_dadda_cla8", unsigned_adder_class_name=UnsignedCarryLookaheadAdder)
u_dadda.get_v_code_hier(open("h_u_dadda_cla8.v", "w"))
```

### Simple arithmetic circuits
See [Ripple Carry Adder](ariths_gen/multi_bit_circuits/adders/ripple_carry_adder.py) file for a basic example.

### Complex circuits
It is possible to combine some basic circuits to generate more complex circuits (such as MAC). The design can be parametrised (i.e., you can pass `UnsignedArraymultiplier` as an input parameter).

```py
from ariths_gen.core.arithmetic_circuits.arithmetic_circuit import ArithmeticCircuit
from ariths_gen.core.arithmetic_circuits import GeneralCircuit
from ariths_gen.wire_components import Bus, Wire
from ariths_gen.multi_bit_circuits.adders import UnsignedRippleCarryAdder
from ariths_gen.multi_bit_circuits.multipliers import UnsignedArrayMultiplier, UnsignedDaddaMultiplier
import os

class MAC(GeneralCircuit):
    def __init__(self, a: Bus, b: Bus, r: Bus, prefix: str = "", name: str = "mac", **kwargs):
        super().__init__(prefix=prefix, name=name, out_N=2*a.N+1, inputs=[a, b, r], **kwargs)
        assert a.N == b.N
        assert r.N == 2 * a.N

        self.mul = self.add_component(UnsignedArrayMultiplier(a=a, b=b, prefix=self.prefix, name=f"u_arrmul{a.N}", inner_component=True))
        self.add = self.add_component(UnsignedRippleCarryAdder(a=r, b=self.mul.out, prefix=self.prefix, name=f"u_rca{r.N}", inner_component=True))
        self.out.connect_bus(connecting_bus=self.add.out)

# usage
if __name__ == "__main__":
    os.makedirs("test_circuits/mac", exist_ok=True)
    mymac = MAC(Bus("a", 8), Bus("b", 8), Bus("acc", 16))
    mymac.get_v_code_hier(open("test_circuits/mac/mac_hier.v", "w"))
    mymac.get_c_code_hier(open("test_circuits/mac/mac_hier.c", "w"))
    mymac.get_c_code_flat(open("test_circuits/mac/mac_flat.c", "w"))
```

## Documentation
The automatically generated documentation is available at 
https://ehw-fit.github.io/ariths-gen/ . 

## CGP testing
The `chr2c.py` script converts the input CGP chromosome generated by ArithsGen to the corresponding C code and prints it to standard output.

### Usage
```bash
python3 chr2c.py input.chr > output.c
```
